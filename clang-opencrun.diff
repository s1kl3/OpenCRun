diff --git a/lib/Basic/TargetInfo.cpp b/lib/Basic/TargetInfo.cpp
index d5dcf06..1f1f4e0 100644
--- a/lib/Basic/TargetInfo.cpp
+++ b/lib/Basic/TargetInfo.cpp
@@ -174,6 +174,13 @@ void TargetInfo::setForcedLangOptions(LangOptions &Opts) {
     UseBitFieldTypeAlignment = false;
   if (Opts.ShortWChar)
     WCharType = UnsignedShort;
+
+  // Data types in OpenCL have a fixed width; char and short hard-coded in
+  // TargetInfo.h. Use natural alignment.
+  if (Opts.OpenCL) {
+    IntWidth = IntAlign = 32;
+    LongWidth = LongAlign = 64;
+  }
 }
 
 //===----------------------------------------------------------------------===//
diff --git a/lib/CodeGen/CGOpenCLRuntime.cpp b/lib/CodeGen/CGOpenCLRuntime.cpp
index 3a0e116..3b51754 100644
--- a/lib/CodeGen/CGOpenCLRuntime.cpp
+++ b/lib/CodeGen/CGOpenCLRuntime.cpp
@@ -22,7 +22,44 @@ using namespace CodeGen;
 
 CGOpenCLRuntime::~CGOpenCLRuntime() {}
 
+void CGOpenCLRuntime::EmitKernelMetadata(CodeGenFunction &CGF,
+                                         const FunctionDecl &FD) {
+  llvm::LLVMContext &Context = CGF.getLLVMContext();
+  llvm::NamedMDNode *OpenCLMetadata =
+    CGF.getModule().getOrInsertNamedMetadata("opencl.kernels");
+
+  llvm::Value *Op = CGF.CurFn;
+  OpenCLMetadata->addOperand(llvm::MDNode::get(Context, Op));
+}
+
 void CGOpenCLRuntime::EmitWorkGroupLocalVarDecl(CodeGenFunction &CGF,
                                                 const VarDecl &D) {
   return CGF.EmitStaticVarDecl(D, llvm::GlobalValue::InternalLinkage);
 }
+
+void CGOpenCRunRuntime::EmitKernelMetadata(CodeGenFunction &CGF,
+                                           const FunctionDecl &FD) {
+  llvm::LLVMContext &Context = CGF.getLLVMContext();
+  llvm::NamedMDNode *OpenCLMetadata =
+    CGF.getModule().getOrInsertNamedMetadata("opencl.kernels");
+  llvm::SmallVector<llvm::Value *, 2> KernMetadata(1, CGF.CurFn);
+
+  llvm::SmallVector<llvm::Value *, 8> AddrSpaces;
+  for(FunctionDecl::param_const_iterator I = FD.param_begin(),
+                                         E = FD.param_end();
+                                         I != E;
+                                         ++I) {
+    unsigned AddrSpace;
+
+    if(const PointerType *Ty = dyn_cast<PointerType>((*I)->getType()))
+      AddrSpace = Ty->getPointeeType().getAddressSpace();
+    else
+      AddrSpace = LangAS::Last;
+
+    AddrSpaces.push_back(
+      llvm::ConstantInt::get(llvm::Type::getInt32Ty(Context), AddrSpace));
+  }
+  KernMetadata.push_back(llvm::MDNode::get(Context, AddrSpaces));
+
+  OpenCLMetadata->addOperand(llvm::MDNode::get(Context, KernMetadata));
+}
diff --git a/lib/CodeGen/CGOpenCLRuntime.h b/lib/CodeGen/CGOpenCLRuntime.h
index 9a8430f..8030e21 100644
--- a/lib/CodeGen/CGOpenCLRuntime.h
+++ b/lib/CodeGen/CGOpenCLRuntime.h
@@ -18,6 +18,7 @@
 
 namespace clang {
 
+class FunctionDecl;
 class VarDecl;
 
 namespace CodeGen {
@@ -33,6 +34,10 @@ public:
   CGOpenCLRuntime(CodeGenModule &CGM) : CGM(CGM) {}
   virtual ~CGOpenCLRuntime();
 
+  // Emit metadata about the given OpenCL kernel. The base class add Fn to the
+  // list of OpenCL kernels.
+  virtual void EmitKernelMetadata(CodeGenFunction &CGF, const FunctionDecl &FD);
+
   /// Emit the IR required for a work-group-local variable declaration, and add
   /// an entry to CGF's LocalDeclMap for D.  The base class does this using
   /// CodeGenFunction::EmitStaticVarDecl to emit an internal global for D.
@@ -40,6 +45,14 @@ public:
                                          const VarDecl &D);
 };
 
+class CGOpenCRunRuntime : public CGOpenCLRuntime {
+public:
+  CGOpenCRunRuntime(CodeGenModule &CGM) : CGOpenCLRuntime(CGM) {}
+
+public:
+  virtual void EmitKernelMetadata(CodeGenFunction &CGF, const FunctionDecl &FD);
+};
+
 }
 }
 
diff --git a/lib/CodeGen/CodeGenFunction.cpp b/lib/CodeGen/CodeGenFunction.cpp
index 4c6624f..3fa9a34 100644
--- a/lib/CodeGen/CodeGenFunction.cpp
+++ b/lib/CodeGen/CodeGenFunction.cpp
@@ -16,6 +16,7 @@
 #include "CGCXXABI.h"
 #include "CGDebugInfo.h"
 #include "CGException.h"
+#include "CGOpenCLRuntime.h"
 #include "clang/Basic/TargetInfo.h"
 #include "clang/AST/APValue.h"
 #include "clang/AST/ASTContext.h"
@@ -267,14 +268,8 @@ void CodeGenFunction::StartFunction(GlobalDecl GD, QualType RetTy,
   if (getContext().getLangOptions().OpenCL) {
     // Add metadata for a kernel function.
     if (const FunctionDecl *FD = dyn_cast_or_null<FunctionDecl>(D))
-      if (FD->hasAttr<OpenCLKernelAttr>()) {
-        llvm::LLVMContext &Context = getLLVMContext();
-        llvm::NamedMDNode *OpenCLMetadata = 
-          CGM.getModule().getOrInsertNamedMetadata("opencl.kernels");
-          
-        llvm::Value *Op = Fn;
-        OpenCLMetadata->addOperand(llvm::MDNode::get(Context, Op));
-      }
+      if (FD->hasAttr<OpenCLKernelAttr>())
+        CGM.getOpenCLRuntime().EmitKernelMetadata(*this, *FD);
   }
 
   llvm::BasicBlock *EntryBB = createBasicBlock("entry", CurFn);
diff --git a/lib/CodeGen/CodeGenFunction.h b/lib/CodeGen/CodeGenFunction.h
index 19541a9..7a0e9c5 100644
--- a/lib/CodeGen/CodeGenFunction.h
+++ b/lib/CodeGen/CodeGenFunction.h
@@ -1143,6 +1143,8 @@ public:
 
   llvm::LLVMContext &getLLVMContext() { return CGM.getLLVMContext(); }
 
+  llvm::Module &getModule() { return CGM.getModule(); }
+
   //===--------------------------------------------------------------------===//
   //                                  Cleanups
   //===--------------------------------------------------------------------===//
diff --git a/lib/CodeGen/CodeGenModule.cpp b/lib/CodeGen/CodeGenModule.cpp
index 408a870..fecb5a5 100644
--- a/lib/CodeGen/CodeGenModule.cpp
+++ b/lib/CodeGen/CodeGenModule.cpp
@@ -128,7 +128,7 @@ void CodeGenModule::createObjCRuntime() {
 }
 
 void CodeGenModule::createOpenCLRuntime() {
-  OpenCLRuntime = new CGOpenCLRuntime(*this);
+  OpenCLRuntime = new CGOpenCRunRuntime(*this);
 }
 
 void CodeGenModule::Release() {
diff --git a/lib/Frontend/InitPreprocessor.cpp b/lib/Frontend/InitPreprocessor.cpp
index 6f49ec4..e1af7f6 100644
--- a/lib/Frontend/InitPreprocessor.cpp
+++ b/lib/Frontend/InitPreprocessor.cpp
@@ -705,6 +705,10 @@ void clang::InitializePreprocessor(Preprocessor &PP,
       AddImplicitInclude(Builder, Path, PP.getFileManager());
   }
 
+  // Add OpenCL definitions.
+  if (PP.getLangOptions().OpenCL)
+    AddImplicitInclude(Builder, "ocldef.h", PP.getFileManager());
+
   // Exit the command line and go back to <built-in> (2 is LC_LEAVE).
   if (!PP.getLangOptions().AsmPreprocessor)
     Builder.append("# 1 \"<built-in>\" 2");
diff --git a/lib/Headers/CMakeLists.txt b/lib/Headers/CMakeLists.txt
index 78fd6f1..19e6589 100644
--- a/lib/Headers/CMakeLists.txt
+++ b/lib/Headers/CMakeLists.txt
@@ -10,6 +10,7 @@ set(files
   mmintrin.h
   mm_malloc.h
   nmmintrin.h
+  ocldef.h
   pmmintrin.h
   smmintrin.h
   stdarg.h
diff --git a/lib/Headers/ocldef.h b/lib/Headers/ocldef.h
new file mode 100644
index 0000000..05a0588
--- /dev/null
+++ b/lib/Headers/ocldef.h
@@ -0,0 +1,241 @@
+//===- TableGen'erated file -------------------------------------*- C++ -*-===//
+//
+// OpenCL C library definitions.
+//
+// Automatically generated file, do not edit!
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef __CLANG_OCLDEF_H
+#define __CLANG_OCLDEF_H
+
+#include <float.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Built-in Scalar Data Types */
+
+typedef unsigned char uchar;
+typedef unsigned short ushort;
+typedef unsigned int uint;
+typedef unsigned long ulong;
+
+/* Built-in Vector Data Types */
+
+typedef __attribute__((ext_vector_type(16))) float float16;
+typedef __attribute__((ext_vector_type(2))) float float2;
+typedef __attribute__((ext_vector_type(3))) float float3;
+typedef __attribute__((ext_vector_type(4))) float float4;
+typedef __attribute__((ext_vector_type(8))) float float8;
+typedef __attribute__((ext_vector_type(16))) int int16;
+typedef __attribute__((ext_vector_type(2))) int int2;
+typedef __attribute__((ext_vector_type(3))) int int3;
+typedef __attribute__((ext_vector_type(4))) int int4;
+typedef __attribute__((ext_vector_type(8))) int int8;
+typedef __attribute__((ext_vector_type(16))) long long16;
+typedef __attribute__((ext_vector_type(2))) long long2;
+typedef __attribute__((ext_vector_type(3))) long long3;
+typedef __attribute__((ext_vector_type(4))) long long4;
+typedef __attribute__((ext_vector_type(8))) long long8;
+typedef __attribute__((ext_vector_type(16))) short short16;
+typedef __attribute__((ext_vector_type(2))) short short2;
+typedef __attribute__((ext_vector_type(3))) short short3;
+typedef __attribute__((ext_vector_type(4))) short short4;
+typedef __attribute__((ext_vector_type(8))) short short8;
+
+/* Other derived types */
+
+typedef ulong cl_mem_fence_flags;
+
+/* Work-Item Functions */
+
+uint __builtin_ocl_get_work_dim();
+size_t __builtin_ocl_get_global_size(uint dimindx);
+size_t __builtin_ocl_get_global_id(uint dimindx);
+size_t __builtin_ocl_get_local_size(uint dimindx);
+size_t __builtin_ocl_get_local_id(uint dimindx);
+size_t __builtin_ocl_get_num_groups(uint dimindx);
+size_t __builtin_ocl_get_group_id(uint dimindx);
+size_t __builtin_ocl_get_global_offset(uint dimindx);
+
+/* Synchronization Functions */
+
+void __builtin_ocl_barrier(cl_mem_fence_flags flags);
+
+/*
+ * These macros are defined in math.h, but because we
+ * cannot include it, define them here. Definitions picked-up
+ * from GNU math.h.
+ */
+
+#define M_E            2.71828182845904523540f  /* e          */
+#define M_LOG2E        1.44269504088896340740f  /* log_2 e    */
+#define M_LOG10E       0.43429448190325182765f  /* log_10 e   */
+#define M_LN2          0.69314718055994530942f  /* log_e 2    */
+#define M_LN10         2.30258509299404568402f  /* log_e 10   */
+#define M_PI           3.14159265358979323846f  /* pi         */
+#define M_PI_2         1.57079632679489661923f  /* pi/2       */
+#define M_PI_4         0.78539816339744830962f  /* pi/4       */
+#define M_1_PI         0.31830988618379067154f  /* 1/pi       */
+#define M_2_PI         0.63661977236758134308f  /* 2/pi       */
+#define M_2_SQRTPI     1.12837916709551257390f  /* 2/sqrt(pi) */
+#define M_SQRT2        1.41421356237309504880f  /* sqrt(2)    */
+#define M_SQRT1_2      0.70710678118654752440f  /* 1/sqrt(2)  */
+
+/* Synchronization Macros*/
+#define CLK_LOCAL_MEM_FENCE  0
+#define CLK_GLOBAL_MEM_FENCE 1
+
+/* Work-Item Rewriting Macros */
+
+#define get_work_dim __builtin_ocl_get_work_dim
+#define get_global_size __builtin_ocl_get_global_size
+#define get_global_id __builtin_ocl_get_global_id
+#define get_local_size __builtin_ocl_get_local_size
+#define get_local_id __builtin_ocl_get_local_id
+#define get_num_groups __builtin_ocl_get_num_groups
+#define get_group_id __builtin_ocl_get_group_id
+#define get_global_offset __builtin_ocl_get_global_offset
+
+/* Synchronization Rewriting Macros */
+
+#define barrier __builtin_ocl_barrier
+
+/* BEGIN AUTO-GENERATED PROTOTYPES */
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_acos(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_acos(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_acos(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_acos(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_acos(float16 x0);
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_acosh(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_acosh(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_acosh(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_acosh(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_acosh(float16 x0);
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_acospi(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_acospi(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_acospi(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_acospi(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_acospi(float16 x0);
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_asin(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_asin(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_asin(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_asin(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_asin(float16 x0);
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_asinh(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_asinh(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_asinh(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_asinh(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_asinh(float16 x0);
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_asinpi(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_asinpi(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_asinpi(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_asinpi(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_asinpi(float16 x0);
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_cos(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_cos(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_cos(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_cos(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_cos(float16 x0);
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_exp(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_exp(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_exp(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_exp(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_exp(float16 x0);
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_sin(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_sin(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_sin(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_sin(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_sin(float16 x0);
+
+__attribute__((overloadable,pure))
+float __builtin_ocl_sqrt(float x0);
+__attribute__((overloadable,pure))
+float2 __builtin_ocl_sqrt(float2 x0);
+__attribute__((overloadable,pure))
+float4 __builtin_ocl_sqrt(float4 x0);
+__attribute__((overloadable,pure))
+float8 __builtin_ocl_sqrt(float8 x0);
+__attribute__((overloadable,pure))
+float16 __builtin_ocl_sqrt(float16 x0);
+
+/* END AUTO-GENERATED PROTOTYPES */
+
+/* BEGIN AUTO-GENERATED BUILTIN MACROS */
+
+#define acos __builtin_ocl_acos
+#define acosh __builtin_ocl_acosh
+#define acospi __builtin_ocl_acospi
+#define asin __builtin_ocl_asin
+#define asinh __builtin_ocl_asinh
+#define asinpi __builtin_ocl_asinpi
+#define cos __builtin_ocl_cos
+#define exp __builtin_ocl_exp
+#define sin __builtin_ocl_sin
+#define sqrt __builtin_ocl_sqrt
+
+/* END AUTO-GENERATED BUILTIN MACROS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CLANG_OCLDEF_H */
